<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Microsoft.CodeAnalysis.CSharp.Features</name>
    </assembly>
    <members>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LambdaUtilities.IsLambda(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Returns true if the specified node represents a lambda.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LambdaUtilities.GetLambda(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Given a node that represents a lambda body returns a node that represents the lambda.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LambdaUtilities.TryGetCorrespondingLambdaBody(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            See SyntaxNode.GetCorrespondingLambdaBody.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LambdaUtilities.IsLambdaBody(Microsoft.CodeAnalysis.SyntaxNode,System.Boolean)">
            <summary>
            Returns true if the specified <paramref name="node"/> represents a body of a lambda.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LambdaUtilities.IsReducedSelectOrGroupByClause(Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>
            When queries are translated into expressions select and group-by expressions such that
            1) select/group-by expression is the same identifier as the "source" identifier and
            2) at least one Where or OrderBy clause but no other clause is present in the contained query body or
               the expression in question is a group-by expression and the body has no clause
            
            do not translate into lambdas.
            By "source" identifier we mean the identifier specified in the from clause that initiates the query or the query continuation that includes the body.
            
            The above condition can be derived from the language specification (chapter 7.16.2) as follows:
            - In order for 7.16.2.5 "Select clauses" to be applicable the following conditions must hold:
              - There has to be at least one clause in the body, otherwise the query is reduced into a final form by 7.16.2.3 "Degenerate query expressions".
              - Only where and order-by clauses may be present in the query body, otherwise a transformation in 7.16.2.4 "From, let, where, join and orderby clauses"
                produces pattern that doesn't match the requirements of 7.16.2.5.
              
            - In order for 7.16.2.6 "Groupby clauses" to be applicable the following conditions must hold:
              - Only where and order-by clauses may be present in the query body, otherwise a transformation in 7.16.2.4 "From, let, where, join and orderby clauses"
                produces pattern that doesn't match the requirements of 7.16.2.5.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LambdaUtilities.IsLambdaBodyStatementOrExpression(Microsoft.CodeAnalysis.SyntaxNode)">
            <remarks>
            In C# lambda bodies are expressions or block statements. In both cases it's a single node.
            In VB a lambda body might be a sequence of nodes (statements). 
            We define this function to minimize differences between C# and VB implementation.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LambdaUtilities.TryGetLambdaBodies(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode@,Microsoft.CodeAnalysis.SyntaxNode@)">
            <summary>
            If the specified node represents a lambda returns a node (or nodes) that represent its body (bodies).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LambdaUtilities.AreEquivalentIgnoringLambdaBodies(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Compares content of two nodes ignoring lambda bodies and trivia.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LambdaUtilities.IsQueryPairLambda(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            "Pair lambda" is a synthesized lambda that creates an instance of an anonymous type representing a pair of values. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LambdaUtilities.IsClosureScope(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Returns true if the specified node can represent a closure scope -- that is a scope of a captured variable.
            Doesn't validate whether or not the node actually declares any captured variable.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.CodeRefactorings.InlineTemporary.InlineTemporaryCodeRefactoringProvider.InitializerRewriter">
            <summary>
            This class handles rewriting initializer expressions that refer to the variable
            being initialized into a simpler form.  For example, in "int x = x = 1", we want to
            get just "1" back as the initializer.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CodeFixes.AddImport.AddImportDiagnosticIds.CS0103">
            <summary>
            name does not exist in context
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CodeFixes.AddImport.AddImportDiagnosticIds.CS0246">
            <summary>
            type or namespace could not be found
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CodeFixes.AddImport.AddImportDiagnosticIds.CS0305">
            <summary>
            wrong number of type args
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CodeFixes.AddImport.AddImportDiagnosticIds.CS1061">
            <summary>
            type does not contain a definition of method or extension method
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CodeFixes.AddImport.AddImportDiagnosticIds.CS1935">
            <summary>
            cannot find implementation of query pattern
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CodeFixes.AddImport.AddImportDiagnosticIds.CS0308">
            <summary>
            The non-generic type 'A' cannot be used with type arguments
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CodeFixes.AddImport.AddImportDiagnosticIds.CS0122">
            <summary>
            'A' is inaccessible due to its protection level
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CodeFixes.AddImport.AddImportDiagnosticIds.CS0307">
            <summary>
            The using alias 'A' cannot be used with type arguments
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CodeFixes.AddImport.AddImportDiagnosticIds.CS0616">
            <summary>
            'A' is not an attribute class
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CodeFixes.AddImport.AddImportDiagnosticIds.CS1501">
            <summary>
             No overload for method 'X' takes 'N' arguments
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CodeFixes.AddImport.AddImportDiagnosticIds.CS1503">
            <summary>
            cannot convert from 'int' to 'string'
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CodeFixes.AddImport.AddImportDiagnosticIds.CS1574">
            <summary>
            XML comment on 'construct' has syntactically incorrect cref attribute 'name'
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CodeFixes.AddImport.AddImportDiagnosticIds.CS1580">
            <summary>
            Invalid type for parameter 'parameter number' in XML comment cref attribute
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CodeFixes.AddImport.AddImportDiagnosticIds.CS1581">
            <summary>
            Invalid return type in XML comment cref attribute
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CodeFixes.AddImport.AddImportDiagnosticIds.CS1584">
            <summary>
            XML comment has syntactically incorrect cref attribute
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CodeFixes.AddImport.AddImportDiagnosticIds.CS1929">
            <summary>
            Type 'X' does not contain a valid extension method accepting 'Y'
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CodeFixes.AddImport.AddImportDiagnosticIds.CS0428">
            <summary>
            Cannot convert method group 'X' to non-delegate type 'Y'. Did you intend to invoke the method?
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CodeFixes.AddImport.AddImportDiagnosticIds.CS7036">
            <summary>
             There is no argument given that corresponds to the required formal parameter 'X' of 'Y'
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeFixes.AddImport.CSharpAddImportCodeFixProvider.#ctor(Microsoft.CodeAnalysis.Packaging.IPackageInstallerService,Microsoft.CodeAnalysis.SymbolSearch.ISymbolSearchService)">
            <summary>For testing purposes only (so that tests can pass in mock values)</summary> 
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CodeFixes.Async.CSharpAddAsyncCodeFixProvider.CS4032">
            <summary>
            The 'await' operator can only be used within an async method. Consider marking this method with the 'async' modifier and changing its return type to 'Task'.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CodeFixes.Async.CSharpAddAsyncCodeFixProvider.CS4033">
            <summary>
            The 'await' operator can only be used within an async method. Consider marking this method with the 'async' modifier and changing its return type to 'Task'.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CodeFixes.Async.CSharpAddAsyncCodeFixProvider.CS4034">
            <summary>
            The 'await' operator can only be used within an async lambda expression. Consider marking this method with the 'async' modifier.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CodeFixes.Async.CSharpAddAwaitCodeFixProvider.CS4014">
            <summary>
            Because this call is not awaited, execution of the current method continues before the call is completed.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CodeFixes.Async.CSharpAddAwaitCodeFixProvider.CS4016">
            <summary>
            Since this is an async method, the return expression must be of type 'blah' rather than 'baz'
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CodeFixes.Async.CSharpAddAwaitCodeFixProvider.CS0029">
            <summary>
            cannot implicitly convert from 'X' to 'Y'.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CodeFixes.Async.CSharpConvertToAsyncMethodCodeFixProvider.CS4008">
            <summary>
            Cannot await void.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CodeFixes.FullyQualify.CSharpFullyQualifyCodeFixProvider.CS0103">
            <summary>
            name does not exist in context
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CodeFixes.FullyQualify.CSharpFullyQualifyCodeFixProvider.CS0104">
            <summary>
            'reference' is an ambiguous reference between 'identifier' and 'identifier'
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CodeFixes.FullyQualify.CSharpFullyQualifyCodeFixProvider.CS0246">
            <summary>
            type or namespace could not be found
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CodeFixes.FullyQualify.CSharpFullyQualifyCodeFixProvider.CS0305">
            <summary>
            wrong number of type args
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CodeFixes.FullyQualify.CSharpFullyQualifyCodeFixProvider.CS0308">
            <summary>
            The non-generic type 'A' cannot be used with type arguments
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CodeFixes.Iterator.CSharpAddYieldCodeFixProvider.CS0029">
            <summary>
            CS0029: Cannot implicitly convert from type 'x' to 'y'
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CodeFixes.Iterator.CSharpAddYieldCodeFixProvider.CS0266">
            <summary>
            CS0266: Cannot implicitly convert from type 'x' to 'y'. An explicit conversion exists (are you missing a cast?)
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CodeFixes.Iterator.CSharpChangeToIEnumerableCodeFixProvider.CS1624">
            <summary>
            CS1624: The body of 'x' cannot be an iterator block because 'y' is not an iterator interface type
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.AnonymousMethod">
            <summary>
              Looks up a localized string similar to anonymous method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.AttributeTarget">
            <summary>
              Looks up a localized string similar to attribute target.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.AutoselectDisabledDueToPossibleExplicitlyNamesAnonTypeMemCreation">
            <summary>
              Looks up a localized string similar to Autoselect disabled due to possible explicitly named anonymous type member creation..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.AutoselectDisabledDueToPotentialImplicitArray">
            <summary>
              Looks up a localized string similar to Autoselect disabled due to potential implicit array creation..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.AutoselectDisabledDueToPotentialLambdaDeclaration">
            <summary>
              Looks up a localized string similar to Autoselect disabled due to potential lambda declaration..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.AutoselectDisabledDueToPotentialRangeVariableDecl">
            <summary>
              Looks up a localized string similar to Autoselect disabled due to potential range variable declaration..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Awaitable">
            <summary>
              Looks up a localized string similar to awaitable.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.AwaitableExtension">
            <summary>
              Looks up a localized string similar to awaitable, extension.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.AwaitExpression">
            <summary>
              Looks up a localized string similar to await expression.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.CantDetermineValidRangeOfStatements">
            <summary>
              Looks up a localized string similar to Can&apos;t determine valid range of statements to extract.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.CastIsRedundant">
            <summary>
              Looks up a localized string similar to Cast is redundant.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.CatchClause">
            <summary>
              Looks up a localized string similar to catch clause.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.ChangeReturnType">
            <summary>
              Looks up a localized string similar to Change return type from {0} to {1}.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.ChangeToYieldReturn">
            <summary>
              Looks up a localized string similar to Replace return with yield return.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.CheckedStatement">
            <summary>
              Looks up a localized string similar to checked statement.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.ConflictsDetected">
            <summary>
              Looks up a localized string similar to Conflict(s) detected..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.ContainsInvalidSelection">
            <summary>
              Looks up a localized string similar to Contains invalid selection..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.ConversionOperator">
            <summary>
              Looks up a localized string similar to conversion operator.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.DelegateInvocationCanBeSimplified">
            <summary>
              Looks up a localized string similar to Delegate invocation can be simplified..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Deprecated">
            <summary>
              Looks up a localized string similar to deprecated.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Destructor">
            <summary>
              Looks up a localized string similar to destructor.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.DoNotChangeThisCodeUseDispose">
            <summary>
              Looks up a localized string similar to Do not change this code. Put cleanup code in Dispose(bool disposing) above..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.ERR_BadCtorArgCount">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; does not contain a constructor that takes that many arguments..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.ERR_NameNotInContext">
            <summary>
              Looks up a localized string similar to The name &apos;{0}&apos; does not exist in the current context..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.EventField">
            <summary>
              Looks up a localized string similar to event field.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.ExplicitConversionDisplayText">
            <summary>
              Looks up a localized string similar to Generate explicit conversion operator in &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Extension">
            <summary>
              Looks up a localized string similar to extension.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.FilterClause">
            <summary>
              Looks up a localized string similar to filter clause.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.FinallyClause">
            <summary>
              Looks up a localized string similar to finally clause.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.FixedStatement">
            <summary>
              Looks up a localized string similar to fixed statement.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.ForEachStatement">
            <summary>
              Looks up a localized string similar to foreach statement.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.FreeUnmanagedResourcesTodo">
            <summary>
              Looks up a localized string similar to TODO: free unmanaged resources (unmanaged objects) and override a finalizer below..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.FromClause">
            <summary>
              Looks up a localized string similar to from clause.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.GlobalStatement">
            <summary>
              Looks up a localized string similar to global statement.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.GroupByClause">
            <summary>
              Looks up a localized string similar to groupby clause.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.HideBase">
            <summary>
              Looks up a localized string similar to Hide base member.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.ImplementAbstractClass">
            <summary>
              Looks up a localized string similar to Implement Abstract Class.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.ImplicitArrayCreation">
            <summary>
              Looks up a localized string similar to &lt;implicit array creation&gt;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.ImplicitConversionDisplayText">
            <summary>
              Looks up a localized string similar to Generate implicit conversion operator in &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Indexer">
            <summary>
              Looks up a localized string similar to indexer.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.IndexerGetter">
            <summary>
              Looks up a localized string similar to indexer getter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.IndexerSetter">
            <summary>
              Looks up a localized string similar to indexer setter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.InlineTemporaryVariable">
            <summary>
              Looks up a localized string similar to Inline temporary variable.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.InsertAwait">
            <summary>
              Looks up a localized string similar to Insert &apos;await&apos;..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.IntoClause">
            <summary>
              Looks up a localized string similar to into clause.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.InvalidSelection">
            <summary>
              Looks up a localized string similar to Invalid selection..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.InvertIfStatement">
            <summary>
              Looks up a localized string similar to Invert if statement.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.JoinClause">
            <summary>
              Looks up a localized string similar to join clause.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Lambda">
            <summary>
              Looks up a localized string similar to lambda.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.LambdaExpression">
            <summary>
              Looks up a localized string similar to &lt;lambda expression&gt;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.LetClause">
            <summary>
              Looks up a localized string similar to let clause.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.LockStatement">
            <summary>
              Looks up a localized string similar to lock statement.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.MakeAsync">
            <summary>
              Looks up a localized string similar to Make the containing scope &apos;async&apos;..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.MemberName">
            <summary>
              Looks up a localized string similar to &lt;member name&gt; = .
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.MoveDeclarationNearReference">
            <summary>
              Looks up a localized string similar to Move declaration near reference.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.NameCanBeSimplified">
            <summary>
              Looks up a localized string similar to Name can be simplified.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.NoCommonRootNodeForExtraction">
            <summary>
              Looks up a localized string similar to No common root node for extraction..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.NotAllCodePathReturns">
            <summary>
              Looks up a localized string similar to Not all code paths return.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.NoValidSelectionToPerformExtraction">
            <summary>
              Looks up a localized string similar to No valid selection to perform extraction..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.NoValidStatementRangeToExtractOut">
            <summary>
              Looks up a localized string similar to No valid statement range to extract.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.OrderByClause">
            <summary>
              Looks up a localized string similar to orderby clause.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.OrganizeUsings">
            <summary>
              Looks up a localized string similar to Organize Usings.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.OrganizeUsingsWithAccelerator">
            <summary>
              Looks up a localized string similar to &amp;Organize Usings.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.OverrideAFinalizerTodo">
            <summary>
              Looks up a localized string similar to TODO: override a finalizer only if Dispose(bool disposing) above has code to free unmanaged resources..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Properties">
            <summary>
              Looks up a localized string similar to Properties.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.PropertyGetter">
            <summary>
              Looks up a localized string similar to property getter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.PropertySetter">
            <summary>
              Looks up a localized string similar to property setter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.QueryBody">
            <summary>
              Looks up a localized string similar to query body.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.RangeVariable">
            <summary>
              Looks up a localized string similar to &lt;range variable&gt;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.RemoveAndSortUsingsWithAccelerator">
            <summary>
              Looks up a localized string similar to Remove &amp;and Sort Usings.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.RemoveUnnecessaryCast">
            <summary>
              Looks up a localized string similar to Remove Unnecessary Cast.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.RemoveUnnecessaryUsings">
            <summary>
              Looks up a localized string similar to Remove Unnecessary Usings.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.RemoveUnnecessaryUsingsDiagnosticTitle">
            <summary>
              Looks up a localized string similar to Using directive is unnecessary..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.RemoveUnnecessaryUsingsWithAccelerator">
            <summary>
              Looks up a localized string similar to &amp;Remove Unnecessary Usings.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.ReturnTaskInsteadOfVoid">
            <summary>
              Looks up a localized string similar to Make {0} return Task instead of void..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.SelectClause">
            <summary>
              Looks up a localized string similar to select clause.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.SelectionCanNotBePartOfConstInitializerExpr">
            <summary>
              Looks up a localized string similar to Selection can not be part of constant initializer expression..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.SelectionCanNotContainAYieldStatement">
            <summary>
              Looks up a localized string similar to Selection can not contain a yield statement..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.SelectionCanNotContainThrowStatement">
            <summary>
              Looks up a localized string similar to Selection can not contain throw statement..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.SelectionCanNotCrossOverPreprocessorDirectives">
            <summary>
              Looks up a localized string similar to Selection can not cross over preprocessor directives..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.SelectionDoesNotContainAValidNode">
            <summary>
              Looks up a localized string similar to Selection does not contain a valid node.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.SelectionDoesNotContainAValidToken">
            <summary>
              Looks up a localized string similar to Selection does not contain a valid token..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.SimplifyAllOccurrences">
            <summary>
              Looks up a localized string similar to Simplify all occurrences.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.SimplifyLambdaExpression">
            <summary>
              Looks up a localized string similar to Simplify lambda expression.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.SimplifyMemberAccess">
            <summary>
              Looks up a localized string similar to Simplify member access &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.SimplifyName">
            <summary>
              Looks up a localized string similar to Simplify name &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.SimplifyThisQualification">
            <summary>
              Looks up a localized string similar to Remove &apos;this&apos; qualification.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.SortUsingsWithAccelerator">
            <summary>
              Looks up a localized string similar to &amp;Sort Usings.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.Struct">
            <summary>
              Looks up a localized string similar to struct.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.TheSelectedCodeIsInsideAnUnsafeContext">
            <summary>
              Looks up a localized string similar to The selected code is inside an unsafe context..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.TheSelectionContainsSyntacticErrors">
            <summary>
              Looks up a localized string similar to The selection contains syntactic errors.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.ThisCodeAddedToCorrectlyImplementDisposable">
            <summary>
              Looks up a localized string similar to This code added to correctly implement the disposable pattern..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.TryBlock">
            <summary>
              Looks up a localized string similar to try block.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.UncheckedStatement">
            <summary>
              Looks up a localized string similar to unchecked statement.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.UncommentTheFollowingIfFinalizerOverriddenTodo">
            <summary>
              Looks up a localized string similar to TODO: uncomment the following line if the finalizer is overridden above..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.UsingDirective">
            <summary>
              Looks up a localized string similar to using directive.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.UsingNamespace">
            <summary>
              Looks up a localized string similar to using namespace.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.UsingStatement">
            <summary>
              Looks up a localized string similar to using statement.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.WarningDeclarationChangesScope">
            <summary>
              Looks up a localized string similar to Warning: Declaration changes scope and may change meaning..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.WhereClause">
            <summary>
              Looks up a localized string similar to where clause.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpFeaturesResources.YieldStatement">
            <summary>
              Looks up a localized string similar to yield statement.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EditAndContinue.BreakpointSpans.TryGetClosestBreakpointSpan(Microsoft.CodeAnalysis.SyntaxNode,System.Int32,Microsoft.CodeAnalysis.Text.TextSpan@)">
            <summary>
            Given a syntax token determines a text span delimited by the closest applicable sequence points 
            encompassing the token.
            </summary>
            <remarks>
            If the span exists it is possible to place a breakpoint at the given position.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EditAndContinue.BreakpointSpans.IsBreakableExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
             <summary>
             There are a few places where we allow breakpoints on expressions. 
            
             1) When the expression is the body of a lambda/method/operator/property/indexer.
             2) The expression is a breakable expression inside a query expression.
             3) The expression is in a for statement initializer, condition or incrementor.
             4) The expression is a foreach initializer.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EditAndContinue.CSharpEditAndContinueAnalyzer.FindMemberDeclaration(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <returns>
            <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax"/> for methods, operators, constructors, destructors and accessors.
            <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax"/> for field initializers.
            <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax"/> for property initializers and expression bodies.
            <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax"/> for indexer expression bodies.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EditAndContinue.CSharpEditAndContinueAnalyzer.TryGetDeclarationBody(Microsoft.CodeAnalysis.SyntaxNode,System.Boolean)">
            <returns>
            Given a node representing a declaration (<paramref name="isMember"/> = true) or a top-level match node (<paramref name="isMember"/> = false) returns:
            - <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax"/> for method-like member declarations with block bodies (methods, operators, constructors, destructors, accessors).
            - <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax"/> for variable declarators of fields, properties with an initializer expression, or 
              for method-like member declarations with expression bodies (methods, properties, indexers, operators)
            
            A null reference otherwise.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EditAndContinue.CSharpEditAndContinueAnalyzer.TryGetActiveTokens(Microsoft.CodeAnalysis.SyntaxNode)">
            <returns>
            If <paramref name="node"/> is a method, accessor, operator, destructor, or constructor without an initializer,
            tokens of its block body, or tokens of the expression body if applicable.
            
            If <paramref name="node"/> is an indexer declaration the tokens of its expression body.
            
            If <paramref name="node"/> is a property declaration the tokens of its expression body or initializer.
              
            If <paramref name="node"/> is a constructor with an initializer, 
            tokens of the initializer concatenated with tokens of the constructor body.
            
            If <paramref name="node"/> is a variable declarator of a field with an initializer,
            tokens of the field initializer.
            
            Null reference otherwise.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EditAndContinue.CSharpEditAndContinueAnalyzer.GetExceptionHandlingRegion(Microsoft.CodeAnalysis.SyntaxNode,System.Boolean@)">
            <summary>
            An active statement (leaf or not) inside a "catch" makes the catch block read-only.
            An active statement (leaf or not) inside a "finally" makes the whole try/catch/finally block read-only.
            An active statement (non leaf)    inside a "try" makes the catch/finally block read-only.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EditAndContinue.StatementSyntaxComparer.Classify(Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.SyntaxNode,System.Boolean@)">
            <summary>
            <paramref name="nodeOpt"/> is null only when comparing value equality of a tree node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EditAndContinue.SyntaxComparer.TryComputeWeightedDistance(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,System.Double@)">
            <summary>
            Calculates distance of two nodes based on their significant parts.
            Returns false if the nodes don't have any significant parts and should be compared as a whole.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EditAndContinue.SyntaxComparer.GetDescendantTokensIgnoringSeparators``1(Microsoft.CodeAnalysis.SeparatedSyntaxList{``0})">
            <summary>
            Enumerates tokens of all nodes in the list. Doesn't include separators.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EditAndContinue.SyntaxComparer.ComputeDistance(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Calculates the distance between two syntax nodes, disregarding trivia. 
            </summary>
            <remarks>
            Distance is a number within [0, 1], the smaller the more similar the nodes are. 
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EditAndContinue.SyntaxComparer.ComputeDistance(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Calculates the distance between two syntax tokens, disregarding trivia. 
            </summary>
            <remarks>
            Distance is a number within [0, 1], the smaller the more similar the tokens are. 
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EditAndContinue.SyntaxComparer.ComputeDistance(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxToken},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxToken})">
            <summary>
            Calculates the distance between two sequences of syntax tokens, disregarding trivia. 
            </summary>
            <remarks>
            Distance is a number within [0, 1], the smaller the more similar the sequences are. 
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EditAndContinue.SyntaxComparer.ComputeDistance(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.SyntaxToken},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.SyntaxToken})">
            <summary>
            Calculates the distance between two sequences of syntax tokens, disregarding trivia. 
            </summary>
            <remarks>
            Distance is a number within [0, 1], the smaller the more similar the sequences are. 
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EditAndContinue.SyntaxComparer.ComputeDistance(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Calculates the distance between two sequences of syntax nodes, disregarding trivia. 
            </summary>
            <remarks>
            Distance is a number within [0, 1], the smaller the more similar the sequences are. 
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EditAndContinue.SyntaxComparer.ComputeDistance(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Calculates the distance between two sequences of syntax tokens, disregarding trivia. 
            </summary>
            <remarks>
            Distance is a number within [0, 1], the smaller the more similar the sequences are. 
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EditAndContinue.SyntaxComparer.GetSequenceEdits(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Calculates the edits that transform one sequence of syntax nodes to another, disregarding trivia.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EditAndContinue.SyntaxComparer.GetSequenceEdits(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Calculates the edits that transform one sequence of syntax nodes to another, disregarding trivia.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EditAndContinue.SyntaxComparer.GetSequenceEdits(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxToken},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxToken})">
            <summary>
            Calculates the edits that transform one sequence of syntax tokens to another, disregarding trivia.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EditAndContinue.SyntaxComparer.GetSequenceEdits(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.SyntaxToken},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.SyntaxToken})">
            <summary>
            Calculates the edits that transform one sequence of syntax tokens to another, disregarding trivia.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EditAndContinue.TopSyntaxComparer.TiedToAncestor(Microsoft.CodeAnalysis.CSharp.EditAndContinue.TopSyntaxComparer.Label)">
            <summary>
            Return 1 if it is desirable to report two edits (delete and insert) rather than a move edit
            when the node changes its parent.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.IntroduceVariable.CSharpIntroduceVariableService.CanIntroduceVariableFor(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>
            Checks for conditions where we should not generate a variable for an expression
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.SignatureHelp.ElementAccessExpressionSignatureHelpProvider.IncompleteElementAccessExpression">
            Error tolerance case for
                "foo[$$]" or "foo?[$$]"
            which is parsed as an ArrayTypeSyntax variable declaration instead of an ElementAccessExpression  
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.SignatureHelp.ElementAccessExpressionSignatureHelpProvider.ConditionalAccessExpression">
            Error tolerance case for
                "new String()?[$$]"
            which is parsed as a BracketedArgumentListSyntax parented by an ElementBindingExpressionSyntax parented by a ConditionalAccessExpressionSyntax
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpDeclarationComputer.GetExpressionBodySyntax(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)">
            <summary>
            Gets the expression-body syntax from an expression-bodied member. The
            given syntax must be for a member which could contain an expression-body.
            </summary>
        </member>
    </members>
</doc>
