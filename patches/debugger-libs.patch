diff --git a/Mono.Debugging.Soft/SoftDebuggerSession.cs b/Mono.Debugging.Soft/SoftDebuggerSession.cs
index b4c6854..a5d4f8e 100644
--- a/Mono.Debugging.Soft/SoftDebuggerSession.cs
+++ b/Mono.Debugging.Soft/SoftDebuggerSession.cs
@@ -55,6 +55,8 @@ namespace Mono.Debugging.Soft
 		readonly Dictionary<long,ObjectMirror> activeExceptionsByThread = new Dictionary<long, ObjectMirror> ();
 		readonly Dictionary<EventRequest, BreakInfo> breakpoints = new Dictionary<EventRequest, BreakInfo> ();
 		readonly Dictionary<string, MonoSymbolFile> symbolFiles = new Dictionary<string, MonoSymbolFile> ();
+		readonly Dictionary<string, string> symbolFileCopies = new Dictionary<string, string> ();
+		readonly Dictionary<AssemblyMirror, string> assemblyLocations = new Dictionary<AssemblyMirror, string>();
 		readonly Dictionary<TypeMirror, string[]> type_to_source = new Dictionary<TypeMirror, string[]> ();
 		readonly Dictionary<string, TypeMirror> aliases = new Dictionary<string, TypeMirror> ();
 		readonly Dictionary<string, TypeMirror> types = new Dictionary<string, TypeMirror> ();
@@ -524,6 +526,38 @@ namespace Mono.Debugging.Soft
 			if (!types.TryGetValue (fullName, out tm))
 				aliases.TryGetValue (fullName, out tm);
 
+			if (tm == null)
+				return null;
+
+			// Work-around for "ERR_UNLOADED" error when evaluating enums:
+			// mscorlib is never unloaded. Check whether
+			// the TypeMirror for a mscorlib type is from
+			// another domain that has been unloaded.
+			// More details: https://github.com/mono/debugger-libs/issues/57
+
+			string aname = tm.Assembly.GetName().Name;
+
+			if (aname == "mscorlib")
+			{
+				try
+				{
+					tm.GetTypeObject();
+				}
+				catch (CommandException e)
+				{
+					if (e.ErrorCode == ErrorCode.ERR_UNLOADED)
+					{
+						if (tm.IsNested)
+							aliases.Remove(NestedTypeNameToAlias(fullName));
+
+						types.Remove(fullName);
+
+						return null;
+					}
+				}
+
+			}
+
 			return tm;
 		}
 		
@@ -552,6 +586,7 @@ namespace Mono.Debugging.Soft
 				symfile.Value.Dispose ();
 
 			symbolFiles.Clear ();
+			symbolFileCopies.Clear ();
 
 			if (!HasExited) {
 				if (vm != null) {
@@ -1026,7 +1061,10 @@ namespace Mono.Debugging.Soft
 				var bi = (BreakInfo) eventInfo;
 				if (bi.Requests.Count != 0) {
 					foreach (var request in bi.Requests)
+					{
+						breakpoints.Remove (request);
 						request.Enabled = false;
+					}
 
 					RemoveQueuedBreakEvents (bi.Requests);
 				}
@@ -1044,7 +1082,9 @@ namespace Mono.Debugging.Soft
 				var bi = (BreakInfo) eventInfo;
 				if (bi.Requests.Count != 0) {
 					foreach (var request in bi.Requests)
+					{
 						request.Enabled = enable;
+					}
 
 					if (!enable)
 						RemoveQueuedBreakEvents (bi.Requests);
@@ -1793,6 +1833,7 @@ namespace Mono.Debugging.Soft
 			bool isExternal;
 			lock (pending_bes) {
 				isExternal = !UpdateAssemblyFilters (asm) && userAssemblyNames != null;
+				assemblyLocations[asm] = asm.Location;
 			}
 
 			string flagExt = isExternal ? " [External]" : "";
@@ -1802,6 +1843,16 @@ namespace Mono.Debugging.Soft
 		void HandleAssemblyUnloadEvents (AssemblyUnloadEvent[] events)
 		{
 			var asm = events [0].Assembly;
+			String asmLocation;
+
+			lock (pending_bes)
+			{
+				if (!assemblyLocations.TryGetValue(asm, out asmLocation))
+					return;
+
+				assemblyLocations.Remove(asm);
+			}
+
 			if (events.Length > 1 && events.Any (a => a.Assembly != asm))
 				throw new InvalidOperationException ("Simultaneous AssemblyUnloadEvents for multiple assemblies");
 
@@ -1814,19 +1865,20 @@ namespace Mono.Debugging.Soft
 				// Mark affected breakpoints as pending again
 				var affectedBreakpoints = new List<KeyValuePair<EventRequest, BreakInfo>> (breakpoints.Where (x => x.Value != null && x.Value.Location != null &&
 					x.Value.Location.Method != null && x.Value.Location.Method.DeclaringType != null &&  x.Value.Location.Method.DeclaringType.Assembly != null &&
-					PathComparer.Equals (x.Value.Location.Method.DeclaringType.Assembly.Location, asm.Location)
+					PathComparer.Equals (x.Value.Location.Method.DeclaringType.Assembly.Location, asmLocation)
 				));
 				foreach (var breakpoint in affectedBreakpoints) {
 					string file = breakpoint.Value.Location.SourceFile;
 					int line = breakpoint.Value.Location.LineNumber;
 					OnDebuggerOutput (false, string.Format ("Re-pending breakpoint at {0}:{1}\n", file, line));
 					breakpoints.Remove (breakpoint.Key);
+					breakpoint.Value.Requests.Clear ();
 					pending_bes.Add (breakpoint.Value);
 				}
 
 				// Remove affected types from the loaded types list
 				var affectedTypes = new List<string> (from pair in types
-					 where PathComparer.Equals (pair.Value.Assembly.Location, asm.Location)
+					 where PathComparer.Equals (pair.Value.Assembly.Location, asmLocation)
 					 select pair.Key);
 
 				foreach (string typeName in affectedTypes) {
@@ -1841,10 +1893,10 @@ namespace Mono.Debugging.Soft
 				}
 
 				foreach (var pair in source_to_type) {
-					pair.Value.RemoveAll (m => PathComparer.Equals (m.Assembly.Location, asm.Location));
+					pair.Value.RemoveAll (m => PathComparer.Equals (m.Assembly.Location, asmLocation));
 				}
 			}
-			OnDebuggerOutput (false, string.Format ("Unloaded assembly: {0}\n", asm.Location));
+			OnDebuggerOutput (false, string.Format ("Unloaded assembly: {0}\n", asmLocation));
 		}
 
 		void HandleVMStartEvents (VMStartEvent[] events)
@@ -2483,14 +2535,49 @@ namespace Mono.Debugging.Soft
 			int fileId = -1;
 			
 			try {
+
+				string mdbCopyFileName;
+
+				// Make a copy of the .mdb file as Cecil keeps the file open and this causes
+				// issues on Windows if the file is updated while the soft debugger running.
+				if (!symbolFileCopies.TryGetValue(mdbFileName, out mdbCopyFileName))
+				{
+					mdbCopyFileName = Path.GetTempFileName();
+					DebuggerLoggingService.LogMessage("SoftDebuggerSession: Copying " + mdbFileName + " to " + mdbCopyFileName);
+					File.Copy(mdbFileName, mdbCopyFileName, true);
+					symbolFileCopies.Add(mdbFileName, mdbCopyFileName);
+				}
+				else
+				{
+					// Check if .mdb file has been updated and if so, reload it.
+					if (File.GetLastWriteTimeUtc(mdbFileName) > File.GetLastWriteTimeUtc(mdbCopyFileName))
+					{
+						MonoSymbolFile oldMdb;
+
+						if (!symbolFiles.TryGetValue (mdbFileName, out oldMdb))
+						{
+							DebuggerLoggingService.LogMessage("SoftDebuggerSession: Failed to get  " + mdbFileName + " (Copy: " + mdbCopyFileName + ")");
+							return false;
+						}
+
+						oldMdb.Dispose(); // Close file handle on currently open .mdb file
+						symbolFiles.Remove(mdbFileName);
+						DebuggerLoggingService.LogMessage("SoftDebuggerSession: Copying updated " + mdbFileName + " to " + mdbCopyFileName);
+						File.Copy(mdbFileName, mdbCopyFileName, true);
+					}
+				}
+
 				if (!symbolFiles.TryGetValue (mdbFileName, out mdb)) {
-					if (!File.Exists (mdbFileName))
+					if (!File.Exists (mdbCopyFileName))
 						return false;
-					
-					mdb = MonoSymbolFile.ReadSymbolFile (mdbFileName);
+
+					mdb = MonoSymbolFile.ReadSymbolFile (mdbCopyFileName);
 					symbolFiles.Add (mdbFileName, mdb);
 				}
-			} catch {
+			} 
+			catch (Exception e)
+			{
+				DebuggerLoggingService.LogMessage("SoftDebuggerSession: Exception\n" + e);
 				return false;
 			}
 
@@ -2530,6 +2617,9 @@ namespace Mono.Debugging.Soft
 
 		bool CheckFileMd5 (string file, byte[] hash)
 		{
+			if (hash == null)
+				return false;
+
 			if (File.Exists (file)) {
 				using (var fs = File.OpenRead (file)) {
 					using (var md5 = MD5.Create ()) {
diff --git a/Mono.Debugging/Mono.Debugging.Evaluation/ObjectValueAdaptor.cs b/Mono.Debugging/Mono.Debugging.Evaluation/ObjectValueAdaptor.cs
index 7483a67..68dfe8e 100644
--- a/Mono.Debugging/Mono.Debugging.Evaluation/ObjectValueAdaptor.cs
+++ b/Mono.Debugging/Mono.Debugging.Evaluation/ObjectValueAdaptor.cs
@@ -1188,17 +1188,27 @@ namespace Mono.Debugging.Evaluation
 					proxyType = proxyType.Substring (0, endIndex);
 				}
 			}
-			
-			object ttype = GetType (ctx, proxyType, typeArgs);
+
+			object ttype = null;
+
+			try
+			{
+				ttype = GetType (ctx, proxyType, typeArgs);
+			}
+			catch(Exception)
+			{
+			}
+
 			if (ttype == null) {
 				// the proxy type string might be in the form: "Namespace.TypeName, Assembly...", chop off the ", Assembly..." bit.
 				if ((index = proxyType.IndexOf (',')) != -1)
 					ttype = GetType (ctx, proxyType.Substring (0, index).Trim (), typeArgs);
 			}
-			if (ttype == null)
-				throw new EvaluatorException ("Unknown type '{0}'", data.ProxyType);
 
 			try {
+				if (ttype == null)
+					throw new EvaluatorException ("Unknown type '{0}'", data.ProxyType);
+
 				object val = CreateValue (ctx, ttype, obj);
 				return val ?? obj;
 			} catch (EvaluatorException) {
